#cloud-config
# LiveKit Proxy Cloud-Init Configuration - Following MongoDB Pattern

write_files:
  - path: /opt/livekit-setup.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      set -e

      # Terraform Variables
      DOMAIN_NAME="${domain_name}"
      ELASTIC_IP="${elastic_ip}"
      ECR_REGISTRY="761018882607.dkr.ecr.us-east-1.amazonaws.com"
      ECR_REPOSITORY="10xr-agents/livekit-proxy-service"
      IMAGE_TAG="0.1.0"
      SERVICE_PORT="9000"
      ALT_PORT="8080"
      REGION="india"

      # Log everything with timestamps
      exec > >(tee /var/log/livekit-setup.log)
      exec 2>&1

      log() {
          echo "$(date '+%Y-%m-%d %H:%M:%S'): $1"
      }

      log "### Starting LiveKit Proxy setup ###"
      log "Domain: $DOMAIN_NAME, Elastic IP: $ELASTIC_IP"
      log "ECR: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

      # Update system packages
      log "Updating system packages..."
      apt-get update -y
      DEBIAN_FRONTEND=noninteractive apt-get upgrade -y

      # Install prerequisites
      log "Installing prerequisites..."
      apt-get install -y \
        curl \
        wget \
        gnupg \
        lsb-release \
        ca-certificates \
        apt-transport-https \
        software-properties-common \
        awscli \
        jq \
        netcat-openbsd \
        htop \
        iotop \
        unzip \
        nginx \
        python3-certbot-nginx

      # Region detection with multiple fallbacks (same as MongoDB)
      get_region() {
        local region=""

        # Method 1: Instance metadata (most reliable)
        region=$(curl -s --max-time 10 http://169.254.169.254/latest/meta-data/placement/region 2>/dev/null || echo "")

        if [ -n "$region" ] && [ "$region" != "" ]; then
          echo "$region"
          return 0
        fi

        # Method 2: Availability zone metadata
        local az=$(curl -s --max-time 10 http://169.254.169.254/latest/meta-data/placement/availability-zone 2>/dev/null || echo "")
        if [ -n "$az" ] && [ "$az" != "" ]; then
          region=$${az%?}
          echo "$region"
          return 0
        fi

        # Method 3: AWS configure fallback
        region=$(aws configure get region 2>/dev/null || echo "")
        if [ -n "$region" ] && [ "$region" != "" ]; then
          echo "$region"
          return 0
        fi

        # Method 4: Default fallback
        echo "us-east-1"
      }

      # Configure AWS CLI
      AWS_REGION=$(get_region)
      log "Using AWS region: $AWS_REGION"

      aws configure set region "$AWS_REGION"
      aws configure set default.region "$AWS_REGION"
      export AWS_DEFAULT_REGION="$AWS_REGION"

      # Test AWS connectivity
      log "Testing AWS CLI connectivity..."
      if ! aws sts get-caller-identity >/dev/null 2>&1; then
        log "WARNING: AWS CLI test failed, continuing anyway..."
      else
        log "AWS CLI connectivity confirmed"
      fi

      # Install Docker - Improved installation
      log "Installing Docker..."

      # Remove old versions
      apt-get remove -y docker docker-engine docker.io containerd runc 2>/dev/null || true

      # Add Docker's official GPG key
      curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

      # Add Docker repository
      echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | \
        tee /etc/apt/sources.list.d/docker.list > /dev/null

      # Update package index
      apt-get update -y

      # Install Docker
      apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

      # Start and enable Docker
      systemctl enable docker
      systemctl start docker

      # Add ubuntu user to docker group
      usermod -aG docker ubuntu

      # Install Docker Compose standalone
      log "Installing Docker Compose standalone..."
      DOCKER_COMPOSE_VERSION="v2.24.0"
      curl -L "https://github.com/docker/compose/releases/download/$DOCKER_COMPOSE_VERSION/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
      chmod +x /usr/local/bin/docker-compose
      ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose

      # Verify Docker installation
      log "Verifying Docker installation..."
      docker --version
      docker-compose --version

      # Test Docker
      docker run --rm hello-world

      log "Docker installation completed successfully"

      # Create application directories
      log "Setting up application directories..."
      mkdir -p /opt/livekit-proxy/{logs,config}
      chown -R ubuntu:ubuntu /opt/livekit-proxy

      # Wait for Docker to be fully ready
      log "Waiting for Docker daemon to be fully ready..."
      sleep 30

      # PHASE 1: ECR Authentication and Image Pull
      log "=== PHASE 1: ECR Authentication and Image Pull ==="

      # Authenticate with ECR
      log "Authenticating with ECR..."
      MAX_ECR_RETRIES=5
      ECR_RETRY_COUNT=0

      while [ $ECR_RETRY_COUNT -lt $MAX_ECR_RETRIES ]; do
        if aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $ECR_REGISTRY; then
          log "ECR authentication successful"
          break
        else
          ECR_RETRY_COUNT=$((ECR_RETRY_COUNT + 1))
          log "ECR authentication failed, retry $ECR_RETRY_COUNT/$MAX_ECR_RETRIES"
          if [ $ECR_RETRY_COUNT -lt $MAX_ECR_RETRIES ]; then
            sleep 10
          else
            log "ERROR: ECR authentication failed after $MAX_ECR_RETRIES attempts"
            exit 1
          fi
        fi
      done

      # Pull Docker image
      log "Pulling Docker image..."
      FULL_IMAGE="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

      MAX_PULL_RETRIES=3
      PULL_RETRY_COUNT=0

      while [ $PULL_RETRY_COUNT -lt $MAX_PULL_RETRIES ]; do
        if docker pull "$FULL_IMAGE"; then
          log "Docker image pulled successfully: $FULL_IMAGE"
          break
        else
          PULL_RETRY_COUNT=$((PULL_RETRY_COUNT + 1))
          log "Docker pull failed, retry $PULL_RETRY_COUNT/$MAX_PULL_RETRIES"
          if [ $PULL_RETRY_COUNT -lt $MAX_PULL_RETRIES ]; then
            sleep 15
          else
            log "ERROR: Docker pull failed after $MAX_PULL_RETRIES attempts"
            exit 1
          fi
        fi
      done

      # PHASE 2: Service Configuration
      log "=== PHASE 2: Service Configuration ==="

      # Configure Nginx
      log "Configuring Nginx..."

      # Remove default site
      rm -f /etc/nginx/sites-enabled/default

      # Add rate limiting configuration to main nginx.conf
      # First, backup the original nginx.conf
      cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.backup

      # Add rate limiting zone to http block in nginx.conf
      sed -i '/http {/a\\n\t# Rate limiting configuration\n\tlimit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;\n' /etc/nginx/nginx.conf

      # Create Nginx configuration for the site (without limit_req_zone)
      cat > /etc/nginx/sites-available/livekit-proxy <<EOF
      server {
          listen 80;
          server_name $DOMAIN_NAME $ELASTIC_IP;

          # Increase client max body size
          client_max_body_size 100M;

          # Health check endpoint
          location /nginx-health {
              return 200 'Nginx OK';
              add_header Content-Type text/plain;
              access_log off;
          }

          # Proxy all requests to the application
          location / {
              limit_req zone=api burst=20 nodelay;

              proxy_pass http://localhost:$SERVICE_PORT;
              proxy_set_header Host \$host;
              proxy_set_header X-Real-IP \$remote_addr;
              proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto \$scheme;
              proxy_set_header Connection '';
              proxy_http_version 1.1;

              # Timeouts
              proxy_connect_timeout 60s;
              proxy_send_timeout 60s;
              proxy_read_timeout 60s;

              # Buffering
              proxy_buffering on;
              proxy_buffer_size 4k;
              proxy_buffers 8 4k;
          }

          # Alternative port proxy
          location /alt/ {
              proxy_pass http://localhost:$ALT_PORT/;
              proxy_set_header Host \$host;
              proxy_set_header X-Real-IP \$remote_addr;
              proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto \$scheme;
          }

          # Logs
          access_log /var/log/nginx/livekit-proxy.access.log;
          error_log /var/log/nginx/livekit-proxy.error.log;
      }
      EOF

      # Enable the site
      ln -sf /etc/nginx/sites-available/livekit-proxy /etc/nginx/sites-enabled/

      # Test Nginx configuration
      if nginx -t; then
        log "Nginx configuration is valid"
      else
        log "ERROR: Nginx configuration is invalid"
        exit 1
      fi

      # Start Nginx
      systemctl enable nginx
      systemctl start nginx

      log "Nginx configured and started successfully"

      # PHASE 3: LiveKit Service Setup
      log "=== PHASE 3: LiveKit Service Setup ==="

      # Create Docker Compose configuration
      log "Creating Docker Compose configuration..."
      cat > /opt/livekit-proxy/docker-compose.yml <<EOF
      version: '3.8'

      services:
        livekit-proxy:
          image: $FULL_IMAGE
          container_name: livekit-proxy
          ports:
            - "$SERVICE_PORT:$SERVICE_PORT"
            - "$ALT_PORT:$ALT_PORT"
          environment:
            - SERVICE_PORT=$SERVICE_PORT
            - REGION=$REGION
            - NODE_ENV=production
          restart: unless-stopped
          healthcheck:
            test: |
              curl -f http://localhost:$SERVICE_PORT/health || 
              curl -f http://localhost:$SERVICE_PORT/api/v1/management/health || 
              curl -f http://localhost:$SERVICE_PORT/ || 
              exit 1
            interval: 30s
            timeout: 10s
            retries: 5
            start_period: 120s
          logging:
            driver: "json-file"
            options:
              max-size: "10m"
              max-file: "5"
          volumes:
            - /opt/livekit-proxy/logs:/app/logs
          networks:
            - livekit-network

      networks:
        livekit-network:
          driver: bridge
      EOF

      chown ubuntu:ubuntu /opt/livekit-proxy/docker-compose.yml

      # Create startup script
      log "Creating startup script..."
      cat > /opt/livekit-proxy/start.sh <<'EOF'
      #!/bin/bash
      set -e

      cd /opt/livekit-proxy

      # Function to log with timestamp
      log() {
          echo "$(date '+%Y-%m-%d %H:%M:%S'): $1" | tee -a logs/startup.log
      }

      # Create logs directory if it doesn't exist
      mkdir -p logs

      log "Starting LiveKit proxy startup script..."

      log "Re-authenticating with ECR..."
      if ! aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 761018882607.dkr.ecr.us-east-1.amazonaws.com; then
          log "ERROR: Failed to authenticate with ECR"
          exit 1
      fi

      log "Pulling latest Docker image..."
      if ! docker-compose pull; then
          log "ERROR: Failed to pull Docker image"
          exit 1
      fi

      log "Stopping existing containers..."
      docker-compose down || log "No existing containers to stop"

      log "Starting LiveKit proxy service..."
      if ! docker-compose up -d; then
          log "ERROR: Failed to start Docker container"
          exit 1
      fi

      log "Waiting for service to be healthy..."
      sleep 30

      log "Checking service status..."
      docker-compose ps
      docker-compose logs --tail=50

      log "Testing service endpoints..."
      for endpoint in "http://localhost:9000/health" "http://localhost:9000/" "http://localhost:8080/"; do
          if curl -f "$endpoint" >/dev/null 2>&1; then
              log "✓ $endpoint is responding"
          else
              log "✗ $endpoint is not responding"
          fi
      done

      log "LiveKit proxy startup completed"
      EOF

      chmod +x /opt/livekit-proxy/start.sh
      chown ubuntu:ubuntu /opt/livekit-proxy/start.sh

      # Create systemd service
      log "Creating systemd service..."
      cat > /etc/systemd/system/livekit-proxy.service <<EOF
      [Unit]
      Description=LiveKit Proxy Service
      Requires=docker.service
      After=docker.service network-online.target
      Wants=network-online.target

      [Service]
      Type=forking
      RemainAfterExit=yes
      User=ubuntu
      Group=ubuntu
      WorkingDirectory=/opt/livekit-proxy
      ExecStart=/opt/livekit-proxy/start.sh
      ExecStop=/usr/local/bin/docker-compose down
      ExecReload=/usr/local/bin/docker-compose restart
      TimeoutStartSec=300
      Restart=on-failure
      RestartSec=30

      [Install]
      WantedBy=multi-user.target
      EOF

      # Enable systemd service
      systemctl daemon-reload
      systemctl enable livekit-proxy.service

      log "Systemd service created and enabled"

      # PHASE 4: Start Services
      log "=== PHASE 4: Starting Services ==="

      # Start LiveKit proxy
      log "Starting LiveKit proxy service..."
      if systemctl start livekit-proxy.service; then
        log "LiveKit proxy service started successfully"
      else
        log "ERROR: Failed to start LiveKit proxy service"
        systemctl status livekit-proxy.service --no-pager || true
        journalctl -u livekit-proxy.service --no-pager -l || true
        exit 1
      fi

      # Wait for services to stabilize
      log "Waiting for services to stabilize..."
      sleep 60

      # PHASE 5: Health Checks and Validation
      log "=== PHASE 5: Health Checks and Validation ==="

      # Check Docker status
      log "Checking Docker status..."
      if systemctl is-active --quiet docker; then
        log "✓ Docker is running"
      else
        log "✗ Docker is not running"
        exit 1
      fi

      # Check Nginx status
      log "Checking Nginx status..."
      if systemctl is-active --quiet nginx; then
        log "✓ Nginx is running"
      else
        log "✗ Nginx is not running"
        exit 1
      fi

      # Check LiveKit service status
      log "Checking LiveKit service status..."
      if systemctl is-active --quiet livekit-proxy; then
        log "✓ LiveKit proxy service is running"
      else
        log "✗ LiveKit proxy service is not running"
        systemctl status livekit-proxy --no-pager || true
      fi

      # Check container status
      log "Checking container status..."
      cd /opt/livekit-proxy
      docker-compose ps

      # Test endpoints
      log "Testing service endpoints..."
      ENDPOINT_TESTS=0
      ENDPOINT_PASSED=0

      for endpoint in "http://localhost:$SERVICE_PORT/health" "http://localhost:$SERVICE_PORT/" "http://localhost:$ALT_PORT/"; do
        ENDPOINT_TESTS=$((ENDPOINT_TESTS + 1))
        if curl -f --connect-timeout 10 "$endpoint" >/dev/null 2>&1; then
          log "✓ $endpoint is responding"
          ENDPOINT_PASSED=$((ENDPOINT_PASSED + 1))
        else
          log "✗ $endpoint is not responding"
        fi
      done

      log "Endpoint test results: $ENDPOINT_PASSED/$ENDPOINT_TESTS passed"

      # Test external access (if possible)
      if [ -n "$ELASTIC_IP" ] && [ "$ELASTIC_IP" != "null" ]; then
        log "Testing external access via $ELASTIC_IP..."
        if curl -f --connect-timeout 15 "http://$ELASTIC_IP/" >/dev/null 2>&1; then
          log "✓ External access test passed"
        else
          log "✗ External access test failed (this might be expected during initial setup)"
        fi
      fi

      # Final status report
      log "=== FINAL STATUS REPORT ==="
      log "LiveKit Proxy setup completed!"
      log "Services status:"
      log "  Docker: $(systemctl is-active docker)"
      log "  Nginx: $(systemctl is-active nginx)"
      log "  LiveKit Proxy: $(systemctl is-active livekit-proxy)"

      log "Network status:"
      ss -tln | grep -E ':(80|443|8080|9000)\s' | while read line; do
        log "  $line"
      done

      log "Container status:"
      docker-compose ps 2>/dev/null | while read line; do
        log "  $line"
      done

      # Create completion marker
      echo "$(date): LiveKit proxy setup completed successfully" > /var/log/livekit-setup-complete

      log "✅ LiveKit Proxy setup completed successfully!"

runcmd:
  - bash /opt/livekit-setup.sh

final_message: "✅ LiveKit Proxy installation and configuration completed!"
